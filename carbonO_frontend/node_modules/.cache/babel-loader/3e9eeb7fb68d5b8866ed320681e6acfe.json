{"ast":null,"code":"'use strict';\n\nconst util = require('../core/util');\n\nconst {\n  ReadableStreamFrom,\n  toUSVString,\n  isBlobLike\n} = require('./util');\n\nconst {\n  FormData\n} = require('./formdata');\n\nconst {\n  kState\n} = require('./symbols');\n\nconst {\n  webidl\n} = require('./webidl');\n\nconst {\n  Blob\n} = require('buffer');\n\nconst {\n  kBodyUsed\n} = require('../core/symbols');\n\nconst assert = require('assert');\n\nconst {\n  NotSupportedError\n} = require('../core/errors');\n\nconst {\n  isErrored\n} = require('../core/util');\n\nconst {\n  isUint8Array,\n  isArrayBuffer\n} = require('util/types');\n\nlet ReadableStream;\n\nasync function* blobGen(blob) {\n  yield* blob.stream();\n} // https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n\n\nfunction extractBody(object) {\n  let keepalive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (!ReadableStream) {\n    ReadableStream = require('stream/web').ReadableStream;\n  } // 1. Let stream be object if object is a ReadableStream object.\n  // Otherwise, let stream be a new ReadableStream, and set up stream.\n\n\n  let stream = null; // 2. Let action be null.\n\n  let action = null; // 3. Let source be null.\n\n  let source = null; // 4. Let length be null.\n\n  let length = null; // 5. Let Content-Type be null.\n\n  let contentType = null; // 6. Switch on object:\n\n  if (object == null) {// Note: The IDL processor cannot handle this situation. See\n    // https://crbug.com/335871.\n  } else if (object instanceof URLSearchParams) {\n    // URLSearchParams\n    // spec says to run application/x-www-form-urlencoded on body.list\n    // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n    // Set source to the result of running the application/x-www-form-urlencoded serializer with object’s list.\n    source = object.toString(); // Set Content-Type to `application/x-www-form-urlencoded;charset=UTF-8`.\n\n    contentType = 'application/x-www-form-urlencoded;charset=UTF-8';\n  } else if (isArrayBuffer(object)) {\n    // BufferSource/ArrayBuffer\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.slice());\n  } else if (ArrayBuffer.isView(object)) {\n    // BufferSource/ArrayBufferView\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));\n  } else if (util.isFormDataLike(object)) {\n    const boundary = '----formdata-undici-' + Math.random();\n    const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`;\n    /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n\n    const escape = str => str.replace(/\\n/g, '%0A').replace(/\\r/g, '%0D').replace(/\"/g, '%22');\n\n    const normalizeLinefeeds = value => value.replace(/\\r?\\n|\\r/g, '\\r\\n'); // Set action to this step: run the multipart/form-data\n    // encoding algorithm, with object’s entry list and UTF-8.\n\n\n    action = async function* (object) {\n      const enc = new TextEncoder();\n\n      for (const [name, value] of object) {\n        if (typeof value === 'string') {\n          yield enc.encode(prefix + `; name=\"${escape(normalizeLinefeeds(name))}\"` + `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`);\n        } else {\n          yield enc.encode(prefix + `; name=\"${escape(normalizeLinefeeds(name))}\"` + (value.name ? `; filename=\"${escape(value.name)}\"` : '') + '\\r\\n' + `Content-Type: ${value.type || 'application/octet-stream'}\\r\\n\\r\\n`);\n          yield* blobGen(value);\n          yield enc.encode('\\r\\n');\n        }\n      }\n\n      yield enc.encode(`--${boundary}--`);\n    }; // Set source to object.\n\n\n    source = object; // Set length to unclear, see html/6424 for improving this.\n    // TODO\n    // Set Content-Type to `multipart/form-data; boundary=`,\n    // followed by the multipart/form-data boundary string generated\n    // by the multipart/form-data encoding algorithm.\n\n    contentType = 'multipart/form-data; boundary=' + boundary;\n  } else if (isBlobLike(object)) {\n    // Blob\n    // Set action to this step: read object.\n    action = blobGen; // Set source to object.\n\n    source = object; // Set length to object’s size.\n\n    length = object.size; // If object’s type attribute is not the empty byte sequence, set\n    // Content-Type to its value.\n\n    if (object.type) {\n      contentType = object.type;\n    }\n  } else if (typeof object[Symbol.asyncIterator] === 'function') {\n    // If keepalive is true, then throw a TypeError.\n    if (keepalive) {\n      throw new TypeError('keepalive');\n    } // If object is disturbed or locked, then throw a TypeError.\n\n\n    if (util.isDisturbed(object) || object.locked) {\n      throw new TypeError('Response body object should not be disturbed or locked');\n    }\n\n    stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);\n  } else {\n    // TODO: byte sequence?\n    // TODO: scalar value string?\n    // TODO: else?\n    source = toUSVString(object);\n    contentType = 'text/plain;charset=UTF-8';\n  } // 7. If source is a byte sequence, then set action to a\n  // step that returns source and length to source’s length.\n  // TODO: What is a \"byte sequence?\"\n\n\n  if (typeof source === 'string' || util.isBuffer(source)) {\n    length = Buffer.byteLength(source);\n  } // 8. If action is non-null, then run these steps in in parallel:\n\n\n  if (action != null) {\n    // Run action.\n    let iterator;\n    stream = new ReadableStream({\n      async start() {\n        iterator = action(object)[Symbol.asyncIterator]();\n      },\n\n      async pull(controller) {\n        const {\n          value,\n          done\n        } = await iterator.next();\n\n        if (done) {\n          // When running action is done, close stream.\n          queueMicrotask(() => {\n            controller.close();\n          });\n        } else {\n          // Whenever one or more bytes are available and stream is not errored,\n          // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n          // bytes into stream.\n          if (!isErrored(stream)) {\n            controller.enqueue(new Uint8Array(value));\n          }\n        }\n\n        return controller.desiredSize > 0;\n      },\n\n      async cancel(reason) {\n        await iterator.return();\n      }\n\n    });\n  } else if (!stream) {\n    // TODO: Spec doesn't say anything about this?\n    stream = new ReadableStream({\n      async pull(controller) {\n        controller.enqueue(typeof source === 'string' ? new TextEncoder().encode(source) : source);\n        queueMicrotask(() => {\n          controller.close();\n        });\n      }\n\n    });\n  } // 9. Let body be a body whose stream is stream, source is source,\n  // and length is length.\n\n\n  const body = {\n    stream,\n    source,\n    length\n  }; // 10. Return body and Content-Type.\n\n  return [body, contentType];\n} // https://fetch.spec.whatwg.org/#bodyinit-safely-extract\n\n\nfunction safelyExtractBody(object) {\n  let keepalive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (!ReadableStream) {\n    // istanbul ignore next\n    ReadableStream = require('stream/web').ReadableStream;\n  } // To safely extract a body and a `Content-Type` value from\n  // a byte sequence or BodyInit object object, run these steps:\n  // 1. If object is a ReadableStream object, then:\n\n\n  if (object instanceof ReadableStream) {\n    // Assert: object is neither disturbed nor locked.\n    // istanbul ignore next\n    assert(!util.isDisturbed(object), 'disturbed'); // istanbul ignore next\n\n    assert(!object.locked, 'locked');\n  } // 2. Return the results of extracting object.\n\n\n  return extractBody(object, keepalive);\n}\n\nfunction cloneBody(body) {\n  // To clone a body body, run these steps:\n  // https://fetch.spec.whatwg.org/#concept-body-clone\n  // 1. Let « out1, out2 » be the result of teeing body’s stream.\n  const [out1, out2] = body.stream.tee(); // 2. Set body’s stream to out1.\n\n  body.stream = out1; // 3. Return a body whose stream is out2 and other members are copied from body.\n\n  return {\n    stream: out2,\n    length: body.length,\n    source: body.source\n  };\n}\n\nasync function* consumeBody(body) {\n  if (body) {\n    if (isUint8Array(body)) {\n      yield body;\n    } else {\n      const stream = body.stream;\n\n      if (util.isDisturbed(stream)) {\n        throw new TypeError('disturbed');\n      }\n\n      if (stream.locked) {\n        throw new TypeError('locked');\n      } // Compat.\n\n\n      stream[kBodyUsed] = true;\n      yield* stream;\n    }\n  }\n}\n\nfunction bodyMixinMethods(instance) {\n  const methods = {\n    async blob() {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation');\n      }\n\n      const chunks = [];\n\n      for await (const chunk of consumeBody(this[kState].body)) {\n        if (!isUint8Array(chunk)) {\n          throw new TypeError('Expected Uint8Array chunk');\n        } // Assemble one final large blob with Uint8Array's can exhaust memory.\n        // That's why we create create multiple blob's and using references\n\n\n        chunks.push(new Blob([chunk]));\n      }\n\n      return new Blob(chunks, {\n        type: this.headers.get('Content-Type') || ''\n      });\n    },\n\n    async arrayBuffer() {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation');\n      }\n\n      const contentLength = this.headers.get('content-length');\n      const encoded = this.headers.has('content-encoding'); // if we have content length and no encoding, then we can\n      // pre allocate the buffer and just read the data into it\n\n      if (!encoded && contentLength) {\n        const buffer = new Uint8Array(contentLength);\n        let offset = 0;\n\n        for await (const chunk of consumeBody(this[kState].body)) {\n          if (!isUint8Array(chunk)) {\n            throw new TypeError('Expected Uint8Array chunk');\n          }\n\n          buffer.set(chunk, offset);\n          offset += chunk.length;\n        }\n\n        return buffer.buffer;\n      } // if we don't have content length, then we have to allocate 2x the\n      // size of the body, once for consumed data, and once for the final buffer\n      // This could be optimized by using growable ArrayBuffer, but it's not\n      // implemented yet. https://github.com/tc39/proposal-resizablearraybuffer\n\n\n      const chunks = [];\n      let size = 0;\n\n      for await (const chunk of consumeBody(this[kState].body)) {\n        if (!isUint8Array(chunk)) {\n          throw new TypeError('Expected Uint8Array chunk');\n        }\n\n        chunks.push(chunk);\n        size += chunk.byteLength;\n      }\n\n      const buffer = new Uint8Array(size);\n      let offset = 0;\n\n      for (const chunk of chunks) {\n        buffer.set(chunk, offset);\n        offset += chunk.byteLength;\n      }\n\n      return buffer.buffer;\n    },\n\n    async text() {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation');\n      }\n\n      let result = '';\n      const textDecoder = new TextDecoder();\n\n      for await (const chunk of consumeBody(this[kState].body)) {\n        if (!isUint8Array(chunk)) {\n          throw new TypeError('Expected Uint8Array chunk');\n        }\n\n        result += textDecoder.decode(chunk, {\n          stream: true\n        });\n      } // flush\n\n\n      result += textDecoder.decode();\n      return result;\n    },\n\n    async json() {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation');\n      }\n\n      return JSON.parse(await this.text());\n    },\n\n    async formData() {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation');\n      }\n\n      const contentType = this.headers.get('Content-Type'); // If mimeType’s essence is \"multipart/form-data\", then:\n\n      if (/multipart\\/form-data/.test(contentType)) {\n        throw new NotSupportedError('multipart/form-data not supported');\n      } else if (/application\\/x-www-form-urlencoded/.test(contentType)) {\n        // Otherwise, if mimeType’s essence is \"application/x-www-form-urlencoded\", then:\n        // 1. Let entries be the result of parsing bytes.\n        let entries;\n\n        try {\n          let text = ''; // application/x-www-form-urlencoded parser will keep the BOM.\n          // https://url.spec.whatwg.org/#concept-urlencoded-parser\n\n          const textDecoder = new TextDecoder('utf-8', {\n            ignoreBOM: true\n          });\n\n          for await (const chunk of consumeBody(this[kState].body)) {\n            if (!isUint8Array(chunk)) {\n              throw new TypeError('Expected Uint8Array chunk');\n            }\n\n            text += textDecoder.decode(chunk, {\n              stream: true\n            });\n          }\n\n          text += textDecoder.decode();\n          entries = new URLSearchParams(text);\n        } catch (err) {\n          // istanbul ignore next: Unclear when new URLSearchParams can fail on a string.\n          // 2. If entries is failure, then throw a TypeError.\n          throw Object.assign(new TypeError(), {\n            cause: err\n          });\n        } // 3. Return a new FormData object whose entries are entries.\n\n\n        const formData = new FormData();\n\n        for (const [name, value] of entries) {\n          formData.append(name, value);\n        }\n\n        return formData;\n      } else {\n        // Otherwise, throw a TypeError.\n        webidl.errors.exception({\n          header: `${instance.name}.formData`,\n          value: 'Could not parse content as FormData.'\n        });\n      }\n    }\n\n  };\n  return methods;\n}\n\nconst properties = {\n  body: {\n    enumerable: true,\n\n    get() {\n      if (!this || !this[kState]) {\n        throw new TypeError('Illegal invocation');\n      }\n\n      return this[kState].body ? this[kState].body.stream : null;\n    }\n\n  },\n  bodyUsed: {\n    enumerable: true,\n\n    get() {\n      if (!this || !this[kState]) {\n        throw new TypeError('Illegal invocation');\n      }\n\n      return !!this[kState].body && util.isDisturbed(this[kState].body.stream);\n    }\n\n  }\n};\n\nfunction mixinBody(prototype) {\n  Object.assign(prototype.prototype, bodyMixinMethods(prototype));\n  Object.defineProperties(prototype.prototype, properties);\n}\n\nmodule.exports = {\n  extractBody,\n  safelyExtractBody,\n  cloneBody,\n  mixinBody\n};","map":{"version":3,"names":["util","require","ReadableStreamFrom","toUSVString","isBlobLike","FormData","kState","webidl","Blob","kBodyUsed","assert","NotSupportedError","isErrored","isUint8Array","isArrayBuffer","ReadableStream","blobGen","blob","stream","extractBody","object","keepalive","action","source","length","contentType","URLSearchParams","toString","Uint8Array","slice","ArrayBuffer","isView","buffer","byteOffset","byteLength","isFormDataLike","boundary","Math","random","prefix","escape","str","replace","normalizeLinefeeds","value","enc","TextEncoder","name","encode","type","size","Symbol","asyncIterator","TypeError","isDisturbed","locked","isBuffer","Buffer","iterator","start","pull","controller","done","next","queueMicrotask","close","enqueue","desiredSize","cancel","reason","return","body","safelyExtractBody","cloneBody","out1","out2","tee","consumeBody","bodyMixinMethods","instance","methods","chunks","chunk","push","headers","get","arrayBuffer","contentLength","encoded","has","offset","set","text","result","textDecoder","TextDecoder","decode","json","JSON","parse","formData","test","entries","ignoreBOM","err","Object","assign","cause","append","errors","exception","header","properties","enumerable","bodyUsed","mixinBody","prototype","defineProperties","module","exports"],"sources":["/Users/noviaantony/Desktop/CS203-Team-2/carbonO_frontend/node_modules/undici/lib/fetch/body.js"],"sourcesContent":["'use strict'\n\nconst util = require('../core/util')\nconst { ReadableStreamFrom, toUSVString, isBlobLike } = require('./util')\nconst { FormData } = require('./formdata')\nconst { kState } = require('./symbols')\nconst { webidl } = require('./webidl')\nconst { Blob } = require('buffer')\nconst { kBodyUsed } = require('../core/symbols')\nconst assert = require('assert')\nconst { NotSupportedError } = require('../core/errors')\nconst { isErrored } = require('../core/util')\nconst { isUint8Array, isArrayBuffer } = require('util/types')\n\nlet ReadableStream\n\nasync function * blobGen (blob) {\n  yield * blob.stream()\n}\n\n// https://fetch.spec.whatwg.org/#concept-bodyinit-extract\nfunction extractBody (object, keepalive = false) {\n  if (!ReadableStream) {\n    ReadableStream = require('stream/web').ReadableStream\n  }\n\n  // 1. Let stream be object if object is a ReadableStream object.\n  // Otherwise, let stream be a new ReadableStream, and set up stream.\n  let stream = null\n\n  // 2. Let action be null.\n  let action = null\n\n  // 3. Let source be null.\n  let source = null\n\n  // 4. Let length be null.\n  let length = null\n\n  // 5. Let Content-Type be null.\n  let contentType = null\n\n  // 6. Switch on object:\n  if (object == null) {\n    // Note: The IDL processor cannot handle this situation. See\n    // https://crbug.com/335871.\n  } else if (object instanceof URLSearchParams) {\n    // URLSearchParams\n\n    // spec says to run application/x-www-form-urlencoded on body.list\n    // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n\n    // Set source to the result of running the application/x-www-form-urlencoded serializer with object’s list.\n    source = object.toString()\n\n    // Set Content-Type to `application/x-www-form-urlencoded;charset=UTF-8`.\n    contentType = 'application/x-www-form-urlencoded;charset=UTF-8'\n  } else if (isArrayBuffer(object)) {\n    // BufferSource/ArrayBuffer\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.slice())\n  } else if (ArrayBuffer.isView(object)) {\n    // BufferSource/ArrayBufferView\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength))\n  } else if (util.isFormDataLike(object)) {\n    const boundary = '----formdata-undici-' + Math.random()\n    const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`\n\n    /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n    const escape = (str) =>\n      str.replace(/\\n/g, '%0A').replace(/\\r/g, '%0D').replace(/\"/g, '%22')\n    const normalizeLinefeeds = (value) => value.replace(/\\r?\\n|\\r/g, '\\r\\n')\n\n    // Set action to this step: run the multipart/form-data\n    // encoding algorithm, with object’s entry list and UTF-8.\n    action = async function * (object) {\n      const enc = new TextEncoder()\n\n      for (const [name, value] of object) {\n        if (typeof value === 'string') {\n          yield enc.encode(\n            prefix +\n              `; name=\"${escape(normalizeLinefeeds(name))}\"` +\n              `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`\n          )\n        } else {\n          yield enc.encode(\n            prefix +\n              `; name=\"${escape(normalizeLinefeeds(name))}\"` +\n              (value.name ? `; filename=\"${escape(value.name)}\"` : '') +\n              '\\r\\n' +\n              `Content-Type: ${\n                value.type || 'application/octet-stream'\n              }\\r\\n\\r\\n`\n          )\n\n          yield * blobGen(value)\n\n          yield enc.encode('\\r\\n')\n        }\n      }\n\n      yield enc.encode(`--${boundary}--`)\n    }\n\n    // Set source to object.\n    source = object\n\n    // Set length to unclear, see html/6424 for improving this.\n    // TODO\n\n    // Set Content-Type to `multipart/form-data; boundary=`,\n    // followed by the multipart/form-data boundary string generated\n    // by the multipart/form-data encoding algorithm.\n    contentType = 'multipart/form-data; boundary=' + boundary\n  } else if (isBlobLike(object)) {\n    // Blob\n\n    // Set action to this step: read object.\n    action = blobGen\n\n    // Set source to object.\n    source = object\n\n    // Set length to object’s size.\n    length = object.size\n\n    // If object’s type attribute is not the empty byte sequence, set\n    // Content-Type to its value.\n    if (object.type) {\n      contentType = object.type\n    }\n  } else if (typeof object[Symbol.asyncIterator] === 'function') {\n    // If keepalive is true, then throw a TypeError.\n    if (keepalive) {\n      throw new TypeError('keepalive')\n    }\n\n    // If object is disturbed or locked, then throw a TypeError.\n    if (util.isDisturbed(object) || object.locked) {\n      throw new TypeError(\n        'Response body object should not be disturbed or locked'\n      )\n    }\n\n    stream =\n      object instanceof ReadableStream ? object : ReadableStreamFrom(object)\n  } else {\n    // TODO: byte sequence?\n    // TODO: scalar value string?\n    // TODO: else?\n    source = toUSVString(object)\n    contentType = 'text/plain;charset=UTF-8'\n  }\n\n  // 7. If source is a byte sequence, then set action to a\n  // step that returns source and length to source’s length.\n  // TODO: What is a \"byte sequence?\"\n  if (typeof source === 'string' || util.isBuffer(source)) {\n    length = Buffer.byteLength(source)\n  }\n\n  // 8. If action is non-null, then run these steps in in parallel:\n  if (action != null) {\n    // Run action.\n    let iterator\n    stream = new ReadableStream({\n      async start () {\n        iterator = action(object)[Symbol.asyncIterator]()\n      },\n      async pull (controller) {\n        const { value, done } = await iterator.next()\n        if (done) {\n          // When running action is done, close stream.\n          queueMicrotask(() => {\n            controller.close()\n          })\n        } else {\n          // Whenever one or more bytes are available and stream is not errored,\n          // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n          // bytes into stream.\n          if (!isErrored(stream)) {\n            controller.enqueue(new Uint8Array(value))\n          }\n        }\n        return controller.desiredSize > 0\n      },\n      async cancel (reason) {\n        await iterator.return()\n      }\n    })\n  } else if (!stream) {\n    // TODO: Spec doesn't say anything about this?\n    stream = new ReadableStream({\n      async pull (controller) {\n        controller.enqueue(\n          typeof source === 'string' ? new TextEncoder().encode(source) : source\n        )\n        queueMicrotask(() => {\n          controller.close()\n        })\n      }\n    })\n  }\n\n  // 9. Let body be a body whose stream is stream, source is source,\n  // and length is length.\n  const body = { stream, source, length }\n\n  // 10. Return body and Content-Type.\n  return [body, contentType]\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit-safely-extract\nfunction safelyExtractBody (object, keepalive = false) {\n  if (!ReadableStream) {\n    // istanbul ignore next\n    ReadableStream = require('stream/web').ReadableStream\n  }\n\n  // To safely extract a body and a `Content-Type` value from\n  // a byte sequence or BodyInit object object, run these steps:\n\n  // 1. If object is a ReadableStream object, then:\n  if (object instanceof ReadableStream) {\n    // Assert: object is neither disturbed nor locked.\n    // istanbul ignore next\n    assert(!util.isDisturbed(object), 'disturbed')\n    // istanbul ignore next\n    assert(!object.locked, 'locked')\n  }\n\n  // 2. Return the results of extracting object.\n  return extractBody(object, keepalive)\n}\n\nfunction cloneBody (body) {\n  // To clone a body body, run these steps:\n\n  // https://fetch.spec.whatwg.org/#concept-body-clone\n\n  // 1. Let « out1, out2 » be the result of teeing body’s stream.\n  const [out1, out2] = body.stream.tee()\n\n  // 2. Set body’s stream to out1.\n  body.stream = out1\n\n  // 3. Return a body whose stream is out2 and other members are copied from body.\n  return {\n    stream: out2,\n    length: body.length,\n    source: body.source\n  }\n}\n\nasync function * consumeBody (body) {\n  if (body) {\n    if (isUint8Array(body)) {\n      yield body\n    } else {\n      const stream = body.stream\n\n      if (util.isDisturbed(stream)) {\n        throw new TypeError('disturbed')\n      }\n\n      if (stream.locked) {\n        throw new TypeError('locked')\n      }\n\n      // Compat.\n      stream[kBodyUsed] = true\n\n      yield * stream\n    }\n  }\n}\n\nfunction bodyMixinMethods (instance) {\n  const methods = {\n    async blob () {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation')\n      }\n\n      const chunks = []\n\n      for await (const chunk of consumeBody(this[kState].body)) {\n        if (!isUint8Array(chunk)) {\n          throw new TypeError('Expected Uint8Array chunk')\n        }\n\n        // Assemble one final large blob with Uint8Array's can exhaust memory.\n        // That's why we create create multiple blob's and using references\n        chunks.push(new Blob([chunk]))\n      }\n\n      return new Blob(chunks, { type: this.headers.get('Content-Type') || '' })\n    },\n\n    async arrayBuffer () {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation')\n      }\n\n      const contentLength = this.headers.get('content-length')\n      const encoded = this.headers.has('content-encoding')\n\n      // if we have content length and no encoding, then we can\n      // pre allocate the buffer and just read the data into it\n      if (!encoded && contentLength) {\n        const buffer = new Uint8Array(contentLength)\n        let offset = 0\n\n        for await (const chunk of consumeBody(this[kState].body)) {\n          if (!isUint8Array(chunk)) {\n            throw new TypeError('Expected Uint8Array chunk')\n          }\n\n          buffer.set(chunk, offset)\n          offset += chunk.length\n        }\n\n        return buffer.buffer\n      }\n\n      // if we don't have content length, then we have to allocate 2x the\n      // size of the body, once for consumed data, and once for the final buffer\n\n      // This could be optimized by using growable ArrayBuffer, but it's not\n      // implemented yet. https://github.com/tc39/proposal-resizablearraybuffer\n\n      const chunks = []\n      let size = 0\n\n      for await (const chunk of consumeBody(this[kState].body)) {\n        if (!isUint8Array(chunk)) {\n          throw new TypeError('Expected Uint8Array chunk')\n        }\n\n        chunks.push(chunk)\n        size += chunk.byteLength\n      }\n\n      const buffer = new Uint8Array(size)\n      let offset = 0\n\n      for (const chunk of chunks) {\n        buffer.set(chunk, offset)\n        offset += chunk.byteLength\n      }\n\n      return buffer.buffer\n    },\n\n    async text () {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation')\n      }\n\n      let result = ''\n      const textDecoder = new TextDecoder()\n\n      for await (const chunk of consumeBody(this[kState].body)) {\n        if (!isUint8Array(chunk)) {\n          throw new TypeError('Expected Uint8Array chunk')\n        }\n\n        result += textDecoder.decode(chunk, { stream: true })\n      }\n\n      // flush\n      result += textDecoder.decode()\n\n      return result\n    },\n\n    async json () {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation')\n      }\n\n      return JSON.parse(await this.text())\n    },\n\n    async formData () {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation')\n      }\n\n      const contentType = this.headers.get('Content-Type')\n\n      // If mimeType’s essence is \"multipart/form-data\", then:\n      if (/multipart\\/form-data/.test(contentType)) {\n        throw new NotSupportedError('multipart/form-data not supported')\n      } else if (/application\\/x-www-form-urlencoded/.test(contentType)) {\n        // Otherwise, if mimeType’s essence is \"application/x-www-form-urlencoded\", then:\n\n        // 1. Let entries be the result of parsing bytes.\n        let entries\n        try {\n          let text = ''\n          // application/x-www-form-urlencoded parser will keep the BOM.\n          // https://url.spec.whatwg.org/#concept-urlencoded-parser\n          const textDecoder = new TextDecoder('utf-8', { ignoreBOM: true })\n          for await (const chunk of consumeBody(this[kState].body)) {\n            if (!isUint8Array(chunk)) {\n              throw new TypeError('Expected Uint8Array chunk')\n            }\n            text += textDecoder.decode(chunk, { stream: true })\n          }\n          text += textDecoder.decode()\n          entries = new URLSearchParams(text)\n        } catch (err) {\n          // istanbul ignore next: Unclear when new URLSearchParams can fail on a string.\n          // 2. If entries is failure, then throw a TypeError.\n          throw Object.assign(new TypeError(), { cause: err })\n        }\n\n        // 3. Return a new FormData object whose entries are entries.\n        const formData = new FormData()\n        for (const [name, value] of entries) {\n          formData.append(name, value)\n        }\n        return formData\n      } else {\n        // Otherwise, throw a TypeError.\n        webidl.errors.exception({\n          header: `${instance.name}.formData`,\n          value: 'Could not parse content as FormData.'\n        })\n      }\n    }\n  }\n\n  return methods\n}\n\nconst properties = {\n  body: {\n    enumerable: true,\n    get () {\n      if (!this || !this[kState]) {\n        throw new TypeError('Illegal invocation')\n      }\n\n      return this[kState].body ? this[kState].body.stream : null\n    }\n  },\n  bodyUsed: {\n    enumerable: true,\n    get () {\n      if (!this || !this[kState]) {\n        throw new TypeError('Illegal invocation')\n      }\n\n      return !!this[kState].body && util.isDisturbed(this[kState].body.stream)\n    }\n  }\n}\n\nfunction mixinBody (prototype) {\n  Object.assign(prototype.prototype, bodyMixinMethods(prototype))\n  Object.defineProperties(prototype.prototype, properties)\n}\n\nmodule.exports = {\n  extractBody,\n  safelyExtractBody,\n  cloneBody,\n  mixinBody\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}