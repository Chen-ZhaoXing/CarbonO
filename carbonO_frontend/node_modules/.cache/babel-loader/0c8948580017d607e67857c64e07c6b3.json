{"ast":null,"code":"'use strict';\n\nconst {\n  redirectStatus\n} = require('./constants');\n\nconst {\n  performance\n} = require('perf_hooks');\n\nconst {\n  isBlobLike,\n  toUSVString,\n  ReadableStreamFrom\n} = require('../core/util');\n\nconst assert = require('assert');\n\nconst {\n  isUint8Array\n} = require('util/types');\n\nlet File; // https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable\n\n/** @type {import('crypto')|undefined} */\n\nlet crypto;\n\ntry {\n  crypto = require('crypto');\n} catch {} // https://fetch.spec.whatwg.org/#block-bad-port\n\n\nconst badPorts = ['1', '7', '9', '11', '13', '15', '17', '19', '20', '21', '22', '23', '25', '37', '42', '43', '53', '69', '77', '79', '87', '95', '101', '102', '103', '104', '109', '110', '111', '113', '115', '117', '119', '123', '135', '137', '139', '143', '161', '179', '389', '427', '465', '512', '513', '514', '515', '526', '530', '531', '532', '540', '548', '554', '556', '563', '587', '601', '636', '989', '990', '993', '995', '1719', '1720', '1723', '2049', '3659', '4045', '5060', '5061', '6000', '6566', '6665', '6666', '6667', '6668', '6669', '6697', '10080'];\n\nfunction responseURL(response) {\n  // https://fetch.spec.whatwg.org/#responses\n  // A response has an associated URL. It is a pointer to the last URL\n  // in response’s URL list and null if response’s URL list is empty.\n  const urlList = response.urlList;\n  const length = urlList.length;\n  return length === 0 ? null : urlList[length - 1].toString();\n} // https://fetch.spec.whatwg.org/#concept-response-location-url\n\n\nfunction responseLocationURL(response, requestFragment) {\n  // 1. If response’s status is not a redirect status, then return null.\n  if (!redirectStatus.includes(response.status)) {\n    return null;\n  } // 2. Let location be the result of extracting header list values given\n  // `Location` and response’s header list.\n\n\n  let location = response.headersList.get('location'); // 3. If location is a value, then set location to the result of parsing\n  // location with response’s URL.\n\n  location = location ? new URL(location, responseURL(response)) : null; // 4. If location is a URL whose fragment is null, then set location’s\n  // fragment to requestFragment.\n\n  if (location && !location.hash) {\n    location.hash = requestFragment;\n  } // 5. Return location.\n\n\n  return location;\n}\n/** @returns {URL} */\n\n\nfunction requestCurrentURL(request) {\n  return request.urlList[request.urlList.length - 1];\n}\n\nfunction requestBadPort(request) {\n  // 1. Let url be request’s current URL.\n  const url = requestCurrentURL(request); // 2. If url’s scheme is an HTTP(S) scheme and url’s port is a bad port,\n  // then return blocked.\n\n  if (/^https?:/.test(url.protocol) && badPorts.includes(url.port)) {\n    return 'blocked';\n  } // 3. Return allowed.\n\n\n  return 'allowed';\n}\n\nfunction isFileLike(object) {\n  if (!File) {\n    File = require('./file').File;\n  }\n\n  return object instanceof File || object && (typeof object.stream === 'function' || typeof object.arrayBuffer === 'function') && /^(File)$/.test(object[Symbol.toStringTag]);\n}\n\nfunction isErrorLike(object) {\n  return object instanceof Error || object?.constructor?.name === 'Error' || object?.constructor?.name === 'DOMException';\n} // Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\n\n\nfunction isValidReasonPhrase(statusText) {\n  for (let i = 0; i < statusText.length; ++i) {\n    const c = statusText.charCodeAt(i);\n\n    if (!(c === 0x09 || // HTAB\n    c >= 0x20 && c <= 0x7e || // SP / VCHAR\n    c >= 0x80 && c <= 0xff // obs-text\n    )) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isTokenChar(c) {\n  return !(c >= 0x7f || c <= 0x20 || c === '(' || c === ')' || c === '<' || c === '>' || c === '@' || c === ',' || c === ';' || c === ':' || c === '\\\\' || c === '\"' || c === '/' || c === '[' || c === ']' || c === '?' || c === '=' || c === '{' || c === '}');\n} // See RFC 7230, Section 3.2.6.\n// https://github.com/chromium/chromium/blob/d7da0240cae77824d1eda25745c4022757499131/third_party/blink/renderer/platform/network/http_parsers.cc#L321\n\n\nfunction isValidHTTPToken(characters) {\n  if (!characters || typeof characters !== 'string') {\n    return false;\n  }\n\n  for (let i = 0; i < characters.length; ++i) {\n    const c = characters.charCodeAt(i);\n\n    if (c > 0x7f || !isTokenChar(c)) {\n      return false;\n    }\n  }\n\n  return true;\n} // https://fetch.spec.whatwg.org/#header-name\n// https://github.com/chromium/chromium/blob/b3d37e6f94f87d59e44662d6078f6a12de845d17/net/http/http_util.cc#L342\n\n\nfunction isValidHeaderName(potentialValue) {\n  if (potentialValue.length === 0) {\n    return false;\n  }\n\n  for (const char of potentialValue) {\n    if (!isValidHTTPToken(char)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * @see https://fetch.spec.whatwg.org/#header-value\n * @param {string} potentialValue\n */\n\n\nfunction isValidHeaderValue(potentialValue) {\n  // - Has no leading or trailing HTTP tab or space bytes.\n  // - Contains no 0x00 (NUL) or HTTP newline bytes.\n  if (potentialValue.startsWith('\\t') || potentialValue.startsWith(' ') || potentialValue.endsWith('\\t') || potentialValue.endsWith(' ')) {\n    return false;\n  }\n\n  if (potentialValue.includes('\\0') || potentialValue.includes('\\r') || potentialValue.includes('\\n')) {\n    return false;\n  }\n\n  return true;\n} // https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\n\n\nfunction setRequestReferrerPolicyOnRedirect(request, actualResponse) {\n  //  Given a request request and a response actualResponse, this algorithm\n  //  updates request’s referrer policy according to the Referrer-Policy\n  //  header (if any) in actualResponse.\n  // 1. Let policy be the result of executing § 8.1 Parse a referrer policy\n  // from a Referrer-Policy header on actualResponse.\n  // TODO:  https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header\n  const policy = ''; // 2. If policy is not the empty string, then set request’s referrer policy to policy.\n\n  if (policy !== '') {\n    request.referrerPolicy = policy;\n  }\n} // https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\n\n\nfunction crossOriginResourcePolicyCheck() {\n  // TODO\n  return 'allowed';\n} // https://fetch.spec.whatwg.org/#concept-cors-check\n\n\nfunction corsCheck() {\n  // TODO\n  return 'success';\n} // https://fetch.spec.whatwg.org/#concept-tao-check\n\n\nfunction TAOCheck() {\n  // TODO\n  return 'success';\n}\n\nfunction appendFetchMetadata(httpRequest) {\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n  //  TODO\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n  //  1. Assert: r’s url is a potentially trustworthy URL.\n  //  TODO\n  //  2. Let header be a Structured Header whose value is a token.\n  let header = null; //  3. Set header’s value to r’s mode.\n\n  header = httpRequest.mode; //  4. Set a structured field value `Sec-Fetch-Mode`/header in r’s header list.\n\n  httpRequest.headersList.set('sec-fetch-mode', header); //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n  //  TODO\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n  //  TODO\n} // https://fetch.spec.whatwg.org/#append-a-request-origin-header\n\n\nfunction appendRequestOriginHeader(request) {\n  // 1. Let serializedOrigin be the result of byte-serializing a request origin with request.\n  let serializedOrigin = request.origin; // 2. If request’s response tainting is \"cors\" or request’s mode is \"websocket\", then append (`Origin`, serializedOrigin) to request’s header list.\n\n  if (request.responseTainting === 'cors' || request.mode === 'websocket') {\n    if (serializedOrigin) {\n      request.headersList.append('Origin', serializedOrigin);\n    } // 3. Otherwise, if request’s method is neither `GET` nor `HEAD`, then:\n\n  } else if (request.method !== 'GET' && request.method !== 'HEAD') {\n    // 1. Switch on request’s referrer policy:\n    switch (request.referrerPolicy) {\n      case 'no-referrer':\n        // Set serializedOrigin to `null`.\n        serializedOrigin = null;\n        break;\n\n      case 'no-referrer-when-downgrade':\n      case 'strict-origin':\n      case 'strict-origin-when-cross-origin':\n        // If request’s origin is a tuple origin, its scheme is \"https\", and request’s current URL’s scheme is not \"https\", then set serializedOrigin to `null`.\n        if (/^https:/.test(request.origin) && !/^https:/.test(requestCurrentURL(request))) {\n          serializedOrigin = null;\n        }\n\n        break;\n\n      case 'same-origin':\n        // If request’s origin is not same origin with request’s current URL’s origin, then set serializedOrigin to `null`.\n        if (!sameOrigin(request, requestCurrentURL(request))) {\n          serializedOrigin = null;\n        }\n\n        break;\n\n      default: // Do nothing.\n\n    }\n\n    if (serializedOrigin) {\n      // 2. Append (`Origin`, serializedOrigin) to request’s header list.\n      request.headersList.append('Origin', serializedOrigin);\n    }\n  }\n}\n\nfunction coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {\n  // TODO\n  return performance.now();\n} // https://fetch.spec.whatwg.org/#create-an-opaque-timing-info\n\n\nfunction createOpaqueTimingInfo(timingInfo) {\n  return {\n    startTime: timingInfo.startTime ?? 0,\n    redirectStartTime: 0,\n    redirectEndTime: 0,\n    postRedirectStartTime: timingInfo.startTime ?? 0,\n    finalServiceWorkerStartTime: 0,\n    finalNetworkResponseStartTime: 0,\n    finalNetworkRequestStartTime: 0,\n    endTime: 0,\n    encodedBodySize: 0,\n    decodedBodySize: 0,\n    finalConnectionTimingInfo: null\n  };\n} // https://html.spec.whatwg.org/multipage/origin.html#policy-container\n\n\nfunction makePolicyContainer() {\n  // TODO\n  return {};\n} // https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\n\n\nfunction clonePolicyContainer() {\n  // TODO\n  return {};\n} // https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\n\n\nfunction determineRequestsReferrer(request) {\n  // TODO\n  return 'no-referrer';\n}\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist\n * @param {Uint8Array} bytes\n * @param {string} metadataList\n */\n\n\nfunction bytesMatch(bytes, metadataList) {\n  // If node is not built with OpenSSL support, we cannot check\n  // a request's integrity, so allow it by default (the spec will\n  // allow requests if an invalid hash is given, as precedence).\n\n  /* istanbul ignore if: only if node is built with --without-ssl */\n  if (crypto === undefined) {\n    return true;\n  } // 1. Let parsedMetadata be the result of parsing metadataList.\n\n\n  const parsedMetadata = parseMetadata(metadataList); // 2. If parsedMetadata is no metadata, return true.\n\n  if (parsedMetadata === 'no metadata') {\n    return true;\n  } // 3. If parsedMetadata is the empty set, return true.\n\n\n  if (parsedMetadata.length === 0) {\n    return true;\n  } // 4. Let metadata be the result of getting the strongest\n  //    metadata from parsedMetadata.\n  // Note: this will only work for SHA- algorithms and it's lazy *at best*.\n\n\n  const metadata = parsedMetadata.sort((c, d) => d.algo.localeCompare(c.algo)); // 5. For each item in metadata:\n\n  for (const item of metadata) {\n    // 1. Let algorithm be the alg component of item.\n    const algorithm = item.algo; // 2. Let expectedValue be the val component of item.\n\n    const expectedValue = item.hash; // 3. Let actualValue be the result of applying algorithm to bytes.\n    // Note: \"applying algorithm to bytes\" converts the result to base64\n\n    const actualValue = crypto.createHash(algorithm).update(bytes).digest('base64'); // 4. If actualValue is a case-sensitive match for expectedValue,\n    //    return true.\n\n    if (actualValue === expectedValue) {\n      return true;\n    }\n  } // 6. Return false.\n\n\n  return false;\n} // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options\n// hash-algo is defined in Content Security Policy 2 Section 4.2\n// base64-value is similary defined there\n// VCHAR is defined https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1\n\n\nconst parseHashWithOptions = /((?<algo>sha256|sha384|sha512)-(?<hash>[A-z0-9+/]{1}.*={1,2}))( +[\\x21-\\x7e]?)?/i;\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n * @param {string} metadata\n */\n\nfunction parseMetadata(metadata) {\n  // 1. Let result be the empty set.\n\n  /** @type {{ algo: string, hash: string }[]} */\n  const result = []; // 2. Let empty be equal to true.\n\n  let empty = true;\n  const supportedHashes = crypto.getHashes(); // 3. For each token returned by splitting metadata on spaces:\n\n  for (const token of metadata.split(' ')) {\n    // 1. Set empty to false.\n    empty = false; // 2. Parse token as a hash-with-options.\n\n    const parsedToken = parseHashWithOptions.exec(token); // 3. If token does not parse, continue to the next token.\n\n    if (parsedToken === null || parsedToken.groups === undefined) {\n      // Note: Chromium blocks the request at this point, but Firefox\n      // gives a warning that an invalid integrity was given. The\n      // correct behavior is to ignore these, and subsequently not\n      // check the integrity of the resource.\n      continue;\n    } // 4. Let algorithm be the hash-algo component of token.\n\n\n    const algorithm = parsedToken.groups.algo; // 5. If algorithm is a hash function recognized by the user\n    //    agent, add the parsed token to result.\n\n    if (supportedHashes.includes(algorithm.toLowerCase())) {\n      result.push(parsedToken.groups);\n    }\n  } // 4. Return no metadata if empty is true, otherwise return result.\n\n\n  if (empty === true) {\n    return 'no metadata';\n  }\n\n  return result;\n} // https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\n\n\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {// TODO\n}\n/**\n * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}\n * @param {URL} A\n * @param {URL} B\n */\n\n\nfunction sameOrigin(A, B) {\n  // 1. If A and B are the same opaque origin, then return true.\n  // \"opaque origin\" is an internal value we cannot access, ignore.\n  // 2. If A and B are both tuple origins and their schemes,\n  //    hosts, and port are identical, then return true.\n  if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n    return true;\n  } // 3. Return false.\n\n\n  return false;\n}\n\nfunction createDeferredPromise() {\n  let res;\n  let rej;\n  const promise = new Promise((resolve, reject) => {\n    res = resolve;\n    rej = reject;\n  });\n  return {\n    promise,\n    resolve: res,\n    reject: rej\n  };\n}\n\nfunction isAborted(fetchParams) {\n  return fetchParams.controller.state === 'aborted';\n}\n\nfunction isCancelled(fetchParams) {\n  return fetchParams.controller.state === 'aborted' || fetchParams.controller.state === 'terminated';\n} // https://fetch.spec.whatwg.org/#concept-method-normalize\n\n\nfunction normalizeMethod(method) {\n  return /^(DELETE|GET|HEAD|OPTIONS|POST|PUT)$/i.test(method) ? method.toUpperCase() : method;\n} // https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string\n\n\nfunction serializeJavascriptValueToJSONString(value) {\n  // 1. Let result be ? Call(%JSON.stringify%, undefined, « value »).\n  const result = JSON.stringify(value); // 2. If result is undefined, then throw a TypeError.\n\n  if (result === undefined) {\n    throw new TypeError('Value is not JSON serializable');\n  } // 3. Assert: result is a string.\n\n\n  assert(typeof result === 'string'); // 4. Return result.\n\n  return result;\n} // https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object\n\n\nconst esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())); // https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n\nfunction makeIterator(iterator, name) {\n  const i = {\n    next() {\n      if (Object.getPrototypeOf(this) !== i) {\n        throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);\n      }\n\n      return iterator.next();\n    },\n\n    // The class string of an iterator prototype object for a given interface is the\n    // result of concatenating the identifier of the interface and the string \" Iterator\".\n    [Symbol.toStringTag]: `${name} Iterator`\n  }; // The [[Prototype]] internal slot of an iterator prototype object must be %IteratorPrototype%.\n\n  Object.setPrototypeOf(i, esIteratorPrototype); // esIteratorPrototype needs to be the prototype of i\n  // which is the prototype of an empty object. Yes, it's confusing.\n\n  return Object.setPrototypeOf({}, i);\n}\n/**\n * @see https://fetch.spec.whatwg.org/#body-fully-read\n */\n\n\nasync function fullyReadBody(body, processBody, processBodyError) {\n  // 1. If taskDestination is null, then set taskDestination to\n  //    the result of starting a new parallel queue.\n  // 2. Let promise be the result of fully reading body as promise\n  //    given body.\n  try {\n    /** @type {Uint8Array[]} */\n    const chunks = [];\n    let length = 0;\n    const reader = body.stream.getReader();\n\n    while (true) {\n      const {\n        done,\n        value\n      } = await reader.read();\n\n      if (done === true) {\n        break;\n      } // read-loop chunk steps\n\n\n      assert(isUint8Array(value));\n      chunks.push(value);\n      length += value.byteLength;\n    } // 3. Let fulfilledSteps given a byte sequence bytes be to queue\n    //    a fetch task to run processBody given bytes, with\n    //    taskDestination.\n\n\n    const fulfilledSteps = bytes => queueMicrotask(() => {\n      processBody(bytes);\n    });\n\n    fulfilledSteps(Buffer.concat(chunks, length));\n  } catch (err) {\n    // 4. Let rejectedSteps be to queue a fetch task to run\n    //    processBodyError, with taskDestination.\n    queueMicrotask(() => processBodyError(err));\n  } // 5. React to promise with fulfilledSteps and rejectedSteps.\n\n}\n/**\n * Fetch supports node >= 16.8.0, but Object.hasOwn was added in v16.9.0.\n */\n\n\nconst hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));\n\nmodule.exports = {\n  isAborted,\n  isCancelled,\n  createDeferredPromise,\n  ReadableStreamFrom,\n  toUSVString,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  coarsenedSharedCurrentTime,\n  determineRequestsReferrer,\n  makePolicyContainer,\n  clonePolicyContainer,\n  appendFetchMetadata,\n  appendRequestOriginHeader,\n  TAOCheck,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  createOpaqueTimingInfo,\n  setRequestReferrerPolicyOnRedirect,\n  isValidHTTPToken,\n  requestBadPort,\n  requestCurrentURL,\n  responseURL,\n  responseLocationURL,\n  isBlobLike,\n  isFileLike,\n  isValidReasonPhrase,\n  sameOrigin,\n  normalizeMethod,\n  serializeJavascriptValueToJSONString,\n  makeIterator,\n  isValidHeaderName,\n  isValidHeaderValue,\n  hasOwn,\n  isErrorLike,\n  fullyReadBody,\n  bytesMatch\n};","map":{"version":3,"names":["redirectStatus","require","performance","isBlobLike","toUSVString","ReadableStreamFrom","assert","isUint8Array","File","crypto","badPorts","responseURL","response","urlList","length","toString","responseLocationURL","requestFragment","includes","status","location","headersList","get","URL","hash","requestCurrentURL","request","requestBadPort","url","test","protocol","port","isFileLike","object","stream","arrayBuffer","Symbol","toStringTag","isErrorLike","Error","constructor","name","isValidReasonPhrase","statusText","i","c","charCodeAt","isTokenChar","isValidHTTPToken","characters","isValidHeaderName","potentialValue","char","isValidHeaderValue","startsWith","endsWith","setRequestReferrerPolicyOnRedirect","actualResponse","policy","referrerPolicy","crossOriginResourcePolicyCheck","corsCheck","TAOCheck","appendFetchMetadata","httpRequest","header","mode","set","appendRequestOriginHeader","serializedOrigin","origin","responseTainting","append","method","sameOrigin","coarsenedSharedCurrentTime","crossOriginIsolatedCapability","now","createOpaqueTimingInfo","timingInfo","startTime","redirectStartTime","redirectEndTime","postRedirectStartTime","finalServiceWorkerStartTime","finalNetworkResponseStartTime","finalNetworkRequestStartTime","endTime","encodedBodySize","decodedBodySize","finalConnectionTimingInfo","makePolicyContainer","clonePolicyContainer","determineRequestsReferrer","bytesMatch","bytes","metadataList","undefined","parsedMetadata","parseMetadata","metadata","sort","d","algo","localeCompare","item","algorithm","expectedValue","actualValue","createHash","update","digest","parseHashWithOptions","result","empty","supportedHashes","getHashes","token","split","parsedToken","exec","groups","toLowerCase","push","tryUpgradeRequestToAPotentiallyTrustworthyURL","A","B","hostname","createDeferredPromise","res","rej","promise","Promise","resolve","reject","isAborted","fetchParams","controller","state","isCancelled","normalizeMethod","toUpperCase","serializeJavascriptValueToJSONString","value","JSON","stringify","TypeError","esIteratorPrototype","Object","getPrototypeOf","iterator","makeIterator","next","setPrototypeOf","fullyReadBody","body","processBody","processBodyError","chunks","reader","getReader","done","read","byteLength","fulfilledSteps","queueMicrotask","Buffer","concat","err","hasOwn","dict","key","prototype","hasOwnProperty","call","module","exports"],"sources":["/Users/noviaantony/Desktop/CS203-Team-2/carbonO_frontend/node_modules/undici/lib/fetch/util.js"],"sourcesContent":["'use strict'\n\nconst { redirectStatus } = require('./constants')\nconst { performance } = require('perf_hooks')\nconst { isBlobLike, toUSVString, ReadableStreamFrom } = require('../core/util')\nconst assert = require('assert')\nconst { isUint8Array } = require('util/types')\n\nlet File\n\n// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable\n/** @type {import('crypto')|undefined} */\nlet crypto\n\ntry {\n  crypto = require('crypto')\n} catch {\n\n}\n\n// https://fetch.spec.whatwg.org/#block-bad-port\nconst badPorts = [\n  '1', '7', '9', '11', '13', '15', '17', '19', '20', '21', '22', '23', '25', '37', '42', '43', '53', '69', '77', '79',\n  '87', '95', '101', '102', '103', '104', '109', '110', '111', '113', '115', '117', '119', '123', '135', '137',\n  '139', '143', '161', '179', '389', '427', '465', '512', '513', '514', '515', '526', '530', '531', '532',\n  '540', '548', '554', '556', '563', '587', '601', '636', '989', '990', '993', '995', '1719', '1720', '1723',\n  '2049', '3659', '4045', '5060', '5061', '6000', '6566', '6665', '6666', '6667', '6668', '6669', '6697',\n  '10080'\n]\n\nfunction responseURL (response) {\n  // https://fetch.spec.whatwg.org/#responses\n  // A response has an associated URL. It is a pointer to the last URL\n  // in response’s URL list and null if response’s URL list is empty.\n  const urlList = response.urlList\n  const length = urlList.length\n  return length === 0 ? null : urlList[length - 1].toString()\n}\n\n// https://fetch.spec.whatwg.org/#concept-response-location-url\nfunction responseLocationURL (response, requestFragment) {\n  // 1. If response’s status is not a redirect status, then return null.\n  if (!redirectStatus.includes(response.status)) {\n    return null\n  }\n\n  // 2. Let location be the result of extracting header list values given\n  // `Location` and response’s header list.\n  let location = response.headersList.get('location')\n\n  // 3. If location is a value, then set location to the result of parsing\n  // location with response’s URL.\n  location = location ? new URL(location, responseURL(response)) : null\n\n  // 4. If location is a URL whose fragment is null, then set location’s\n  // fragment to requestFragment.\n  if (location && !location.hash) {\n    location.hash = requestFragment\n  }\n\n  // 5. Return location.\n  return location\n}\n\n/** @returns {URL} */\nfunction requestCurrentURL (request) {\n  return request.urlList[request.urlList.length - 1]\n}\n\nfunction requestBadPort (request) {\n  // 1. Let url be request’s current URL.\n  const url = requestCurrentURL(request)\n\n  // 2. If url’s scheme is an HTTP(S) scheme and url’s port is a bad port,\n  // then return blocked.\n  if (/^https?:/.test(url.protocol) && badPorts.includes(url.port)) {\n    return 'blocked'\n  }\n\n  // 3. Return allowed.\n  return 'allowed'\n}\n\nfunction isFileLike (object) {\n  if (!File) {\n    File = require('./file').File\n  }\n  return object instanceof File || (\n    object &&\n    (typeof object.stream === 'function' ||\n     typeof object.arrayBuffer === 'function') &&\n    /^(File)$/.test(object[Symbol.toStringTag])\n  )\n}\n\nfunction isErrorLike (object) {\n  return object instanceof Error || (\n    object?.constructor?.name === 'Error' ||\n    object?.constructor?.name === 'DOMException'\n  )\n}\n\n// Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\nfunction isValidReasonPhrase (statusText) {\n  for (let i = 0; i < statusText.length; ++i) {\n    const c = statusText.charCodeAt(i)\n    if (\n      !(\n        (\n          c === 0x09 || // HTAB\n          (c >= 0x20 && c <= 0x7e) || // SP / VCHAR\n          (c >= 0x80 && c <= 0xff)\n        ) // obs-text\n      )\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction isTokenChar (c) {\n  return !(\n    c >= 0x7f ||\n    c <= 0x20 ||\n    c === '(' ||\n    c === ')' ||\n    c === '<' ||\n    c === '>' ||\n    c === '@' ||\n    c === ',' ||\n    c === ';' ||\n    c === ':' ||\n    c === '\\\\' ||\n    c === '\"' ||\n    c === '/' ||\n    c === '[' ||\n    c === ']' ||\n    c === '?' ||\n    c === '=' ||\n    c === '{' ||\n    c === '}'\n  )\n}\n\n// See RFC 7230, Section 3.2.6.\n// https://github.com/chromium/chromium/blob/d7da0240cae77824d1eda25745c4022757499131/third_party/blink/renderer/platform/network/http_parsers.cc#L321\nfunction isValidHTTPToken (characters) {\n  if (!characters || typeof characters !== 'string') {\n    return false\n  }\n  for (let i = 0; i < characters.length; ++i) {\n    const c = characters.charCodeAt(i)\n    if (c > 0x7f || !isTokenChar(c)) {\n      return false\n    }\n  }\n  return true\n}\n\n// https://fetch.spec.whatwg.org/#header-name\n// https://github.com/chromium/chromium/blob/b3d37e6f94f87d59e44662d6078f6a12de845d17/net/http/http_util.cc#L342\nfunction isValidHeaderName (potentialValue) {\n  if (potentialValue.length === 0) {\n    return false\n  }\n\n  for (const char of potentialValue) {\n    if (!isValidHTTPToken(char)) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-value\n * @param {string} potentialValue\n */\nfunction isValidHeaderValue (potentialValue) {\n  // - Has no leading or trailing HTTP tab or space bytes.\n  // - Contains no 0x00 (NUL) or HTTP newline bytes.\n  if (\n    potentialValue.startsWith('\\t') ||\n    potentialValue.startsWith(' ') ||\n    potentialValue.endsWith('\\t') ||\n    potentialValue.endsWith(' ')\n  ) {\n    return false\n  }\n\n  if (\n    potentialValue.includes('\\0') ||\n    potentialValue.includes('\\r') ||\n    potentialValue.includes('\\n')\n  ) {\n    return false\n  }\n\n  return true\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\nfunction setRequestReferrerPolicyOnRedirect (request, actualResponse) {\n  //  Given a request request and a response actualResponse, this algorithm\n  //  updates request’s referrer policy according to the Referrer-Policy\n  //  header (if any) in actualResponse.\n\n  // 1. Let policy be the result of executing § 8.1 Parse a referrer policy\n  // from a Referrer-Policy header on actualResponse.\n  // TODO:  https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header\n  const policy = ''\n\n  // 2. If policy is not the empty string, then set request’s referrer policy to policy.\n  if (policy !== '') {\n    request.referrerPolicy = policy\n  }\n}\n\n// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\nfunction crossOriginResourcePolicyCheck () {\n  // TODO\n  return 'allowed'\n}\n\n// https://fetch.spec.whatwg.org/#concept-cors-check\nfunction corsCheck () {\n  // TODO\n  return 'success'\n}\n\n// https://fetch.spec.whatwg.org/#concept-tao-check\nfunction TAOCheck () {\n  // TODO\n  return 'success'\n}\n\nfunction appendFetchMetadata (httpRequest) {\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n\n  //  1. Assert: r’s url is a potentially trustworthy URL.\n  //  TODO\n\n  //  2. Let header be a Structured Header whose value is a token.\n  let header = null\n\n  //  3. Set header’s value to r’s mode.\n  header = httpRequest.mode\n\n  //  4. Set a structured field value `Sec-Fetch-Mode`/header in r’s header list.\n  httpRequest.headersList.set('sec-fetch-mode', header)\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n  //  TODO\n}\n\n// https://fetch.spec.whatwg.org/#append-a-request-origin-header\nfunction appendRequestOriginHeader (request) {\n  // 1. Let serializedOrigin be the result of byte-serializing a request origin with request.\n  let serializedOrigin = request.origin\n\n  // 2. If request’s response tainting is \"cors\" or request’s mode is \"websocket\", then append (`Origin`, serializedOrigin) to request’s header list.\n  if (request.responseTainting === 'cors' || request.mode === 'websocket') {\n    if (serializedOrigin) {\n      request.headersList.append('Origin', serializedOrigin)\n    }\n\n  // 3. Otherwise, if request’s method is neither `GET` nor `HEAD`, then:\n  } else if (request.method !== 'GET' && request.method !== 'HEAD') {\n    // 1. Switch on request’s referrer policy:\n    switch (request.referrerPolicy) {\n      case 'no-referrer':\n        // Set serializedOrigin to `null`.\n        serializedOrigin = null\n        break\n      case 'no-referrer-when-downgrade':\n      case 'strict-origin':\n      case 'strict-origin-when-cross-origin':\n        // If request’s origin is a tuple origin, its scheme is \"https\", and request’s current URL’s scheme is not \"https\", then set serializedOrigin to `null`.\n        if (/^https:/.test(request.origin) && !/^https:/.test(requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      case 'same-origin':\n        // If request’s origin is not same origin with request’s current URL’s origin, then set serializedOrigin to `null`.\n        if (!sameOrigin(request, requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      default:\n        // Do nothing.\n    }\n\n    if (serializedOrigin) {\n      // 2. Append (`Origin`, serializedOrigin) to request’s header list.\n      request.headersList.append('Origin', serializedOrigin)\n    }\n  }\n}\n\nfunction coarsenedSharedCurrentTime (crossOriginIsolatedCapability) {\n  // TODO\n  return performance.now()\n}\n\n// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info\nfunction createOpaqueTimingInfo (timingInfo) {\n  return {\n    startTime: timingInfo.startTime ?? 0,\n    redirectStartTime: 0,\n    redirectEndTime: 0,\n    postRedirectStartTime: timingInfo.startTime ?? 0,\n    finalServiceWorkerStartTime: 0,\n    finalNetworkResponseStartTime: 0,\n    finalNetworkRequestStartTime: 0,\n    endTime: 0,\n    encodedBodySize: 0,\n    decodedBodySize: 0,\n    finalConnectionTimingInfo: null\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#policy-container\nfunction makePolicyContainer () {\n  // TODO\n  return {}\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\nfunction clonePolicyContainer () {\n  // TODO\n  return {}\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\nfunction determineRequestsReferrer (request) {\n  // TODO\n  return 'no-referrer'\n}\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist\n * @param {Uint8Array} bytes\n * @param {string} metadataList\n */\nfunction bytesMatch (bytes, metadataList) {\n  // If node is not built with OpenSSL support, we cannot check\n  // a request's integrity, so allow it by default (the spec will\n  // allow requests if an invalid hash is given, as precedence).\n  /* istanbul ignore if: only if node is built with --without-ssl */\n  if (crypto === undefined) {\n    return true\n  }\n\n  // 1. Let parsedMetadata be the result of parsing metadataList.\n  const parsedMetadata = parseMetadata(metadataList)\n\n  // 2. If parsedMetadata is no metadata, return true.\n  if (parsedMetadata === 'no metadata') {\n    return true\n  }\n\n  // 3. If parsedMetadata is the empty set, return true.\n  if (parsedMetadata.length === 0) {\n    return true\n  }\n\n  // 4. Let metadata be the result of getting the strongest\n  //    metadata from parsedMetadata.\n  // Note: this will only work for SHA- algorithms and it's lazy *at best*.\n  const metadata = parsedMetadata.sort((c, d) => d.algo.localeCompare(c.algo))\n\n  // 5. For each item in metadata:\n  for (const item of metadata) {\n    // 1. Let algorithm be the alg component of item.\n    const algorithm = item.algo\n\n    // 2. Let expectedValue be the val component of item.\n    const expectedValue = item.hash\n\n    // 3. Let actualValue be the result of applying algorithm to bytes.\n    // Note: \"applying algorithm to bytes\" converts the result to base64\n    const actualValue = crypto.createHash(algorithm).update(bytes).digest('base64')\n\n    // 4. If actualValue is a case-sensitive match for expectedValue,\n    //    return true.\n    if (actualValue === expectedValue) {\n      return true\n    }\n  }\n\n  // 6. Return false.\n  return false\n}\n\n// https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options\n// hash-algo is defined in Content Security Policy 2 Section 4.2\n// base64-value is similary defined there\n// VCHAR is defined https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1\nconst parseHashWithOptions = /((?<algo>sha256|sha384|sha512)-(?<hash>[A-z0-9+/]{1}.*={1,2}))( +[\\x21-\\x7e]?)?/i\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n * @param {string} metadata\n */\nfunction parseMetadata (metadata) {\n  // 1. Let result be the empty set.\n  /** @type {{ algo: string, hash: string }[]} */\n  const result = []\n\n  // 2. Let empty be equal to true.\n  let empty = true\n\n  const supportedHashes = crypto.getHashes()\n\n  // 3. For each token returned by splitting metadata on spaces:\n  for (const token of metadata.split(' ')) {\n    // 1. Set empty to false.\n    empty = false\n\n    // 2. Parse token as a hash-with-options.\n    const parsedToken = parseHashWithOptions.exec(token)\n\n    // 3. If token does not parse, continue to the next token.\n    if (parsedToken === null || parsedToken.groups === undefined) {\n      // Note: Chromium blocks the request at this point, but Firefox\n      // gives a warning that an invalid integrity was given. The\n      // correct behavior is to ignore these, and subsequently not\n      // check the integrity of the resource.\n      continue\n    }\n\n    // 4. Let algorithm be the hash-algo component of token.\n    const algorithm = parsedToken.groups.algo\n\n    // 5. If algorithm is a hash function recognized by the user\n    //    agent, add the parsed token to result.\n    if (supportedHashes.includes(algorithm.toLowerCase())) {\n      result.push(parsedToken.groups)\n    }\n  }\n\n  // 4. Return no metadata if empty is true, otherwise return result.\n  if (empty === true) {\n    return 'no metadata'\n  }\n\n  return result\n}\n\n// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL (request) {\n  // TODO\n}\n\n/**\n * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}\n * @param {URL} A\n * @param {URL} B\n */\nfunction sameOrigin (A, B) {\n  // 1. If A and B are the same opaque origin, then return true.\n  // \"opaque origin\" is an internal value we cannot access, ignore.\n\n  // 2. If A and B are both tuple origins and their schemes,\n  //    hosts, and port are identical, then return true.\n  if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n    return true\n  }\n\n  // 3. Return false.\n  return false\n}\n\nfunction createDeferredPromise () {\n  let res\n  let rej\n  const promise = new Promise((resolve, reject) => {\n    res = resolve\n    rej = reject\n  })\n\n  return { promise, resolve: res, reject: rej }\n}\n\nfunction isAborted (fetchParams) {\n  return fetchParams.controller.state === 'aborted'\n}\n\nfunction isCancelled (fetchParams) {\n  return fetchParams.controller.state === 'aborted' ||\n    fetchParams.controller.state === 'terminated'\n}\n\n// https://fetch.spec.whatwg.org/#concept-method-normalize\nfunction normalizeMethod (method) {\n  return /^(DELETE|GET|HEAD|OPTIONS|POST|PUT)$/i.test(method)\n    ? method.toUpperCase()\n    : method\n}\n\n// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string\nfunction serializeJavascriptValueToJSONString (value) {\n  // 1. Let result be ? Call(%JSON.stringify%, undefined, « value »).\n  const result = JSON.stringify(value)\n\n  // 2. If result is undefined, then throw a TypeError.\n  if (result === undefined) {\n    throw new TypeError('Value is not JSON serializable')\n  }\n\n  // 3. Assert: result is a string.\n  assert(typeof result === 'string')\n\n  // 4. Return result.\n  return result\n}\n\n// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object\nconst esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))\n\n// https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\nfunction makeIterator (iterator, name) {\n  const i = {\n    next () {\n      if (Object.getPrototypeOf(this) !== i) {\n        throw new TypeError(\n          `'next' called on an object that does not implement interface ${name} Iterator.`\n        )\n      }\n\n      return iterator.next()\n    },\n    // The class string of an iterator prototype object for a given interface is the\n    // result of concatenating the identifier of the interface and the string \" Iterator\".\n    [Symbol.toStringTag]: `${name} Iterator`\n  }\n\n  // The [[Prototype]] internal slot of an iterator prototype object must be %IteratorPrototype%.\n  Object.setPrototypeOf(i, esIteratorPrototype)\n  // esIteratorPrototype needs to be the prototype of i\n  // which is the prototype of an empty object. Yes, it's confusing.\n  return Object.setPrototypeOf({}, i)\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#body-fully-read\n */\nasync function fullyReadBody (body, processBody, processBodyError) {\n  // 1. If taskDestination is null, then set taskDestination to\n  //    the result of starting a new parallel queue.\n\n  // 2. Let promise be the result of fully reading body as promise\n  //    given body.\n  try {\n    /** @type {Uint8Array[]} */\n    const chunks = []\n    let length = 0\n\n    const reader = body.stream.getReader()\n\n    while (true) {\n      const { done, value } = await reader.read()\n\n      if (done === true) {\n        break\n      }\n\n      // read-loop chunk steps\n      assert(isUint8Array(value))\n\n      chunks.push(value)\n      length += value.byteLength\n    }\n\n    // 3. Let fulfilledSteps given a byte sequence bytes be to queue\n    //    a fetch task to run processBody given bytes, with\n    //    taskDestination.\n    const fulfilledSteps = (bytes) => queueMicrotask(() => {\n      processBody(bytes)\n    })\n\n    fulfilledSteps(Buffer.concat(chunks, length))\n  } catch (err) {\n    // 4. Let rejectedSteps be to queue a fetch task to run\n    //    processBodyError, with taskDestination.\n    queueMicrotask(() => processBodyError(err))\n  }\n\n  // 5. React to promise with fulfilledSteps and rejectedSteps.\n}\n\n/**\n * Fetch supports node >= 16.8.0, but Object.hasOwn was added in v16.9.0.\n */\nconst hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key))\n\nmodule.exports = {\n  isAborted,\n  isCancelled,\n  createDeferredPromise,\n  ReadableStreamFrom,\n  toUSVString,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  coarsenedSharedCurrentTime,\n  determineRequestsReferrer,\n  makePolicyContainer,\n  clonePolicyContainer,\n  appendFetchMetadata,\n  appendRequestOriginHeader,\n  TAOCheck,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  createOpaqueTimingInfo,\n  setRequestReferrerPolicyOnRedirect,\n  isValidHTTPToken,\n  requestBadPort,\n  requestCurrentURL,\n  responseURL,\n  responseLocationURL,\n  isBlobLike,\n  isFileLike,\n  isValidReasonPhrase,\n  sameOrigin,\n  normalizeMethod,\n  serializeJavascriptValueToJSONString,\n  makeIterator,\n  isValidHeaderName,\n  isValidHeaderValue,\n  hasOwn,\n  isErrorLike,\n  fullyReadBody,\n  bytesMatch\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}