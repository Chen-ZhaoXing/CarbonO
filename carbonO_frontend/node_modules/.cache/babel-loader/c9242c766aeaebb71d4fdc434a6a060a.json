{"ast":null,"code":"'use strict';\n\nconst {\n  InvalidArgumentError\n} = require('./core/errors');\n\nconst {\n  kClients,\n  kRunning,\n  kClose,\n  kDestroy,\n  kDispatch\n} = require('./core/symbols');\n\nconst DispatcherBase = require('./dispatcher-base');\n\nconst Pool = require('./pool');\n\nconst Client = require('./client');\n\nconst util = require('./core/util');\n\nconst RedirectHandler = require('./handler/redirect');\n\nconst {\n  WeakRef,\n  FinalizationRegistry\n} = require('./compat/dispatcher-weakref')();\n\nconst kOnConnect = Symbol('onConnect');\nconst kOnDisconnect = Symbol('onDisconnect');\nconst kOnConnectionError = Symbol('onConnectionError');\nconst kMaxRedirections = Symbol('maxRedirections');\nconst kOnDrain = Symbol('onDrain');\nconst kFactory = Symbol('factory');\nconst kFinalizer = Symbol('finalizer');\nconst kOptions = Symbol('options');\n\nfunction defaultFactory(origin, opts) {\n  return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);\n}\n\nclass Agent extends DispatcherBase {\n  constructor() {\n    let {\n      factory = defaultFactory,\n      maxRedirections = 0,\n      connect,\n      ...options\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.');\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object');\n    }\n\n    if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number');\n    }\n\n    if (connect && typeof connect !== 'function') {\n      connect = { ...connect\n      };\n    }\n\n    this[kOptions] = { ...util.deepClone(options),\n      connect\n    };\n    this[kMaxRedirections] = maxRedirections;\n    this[kFactory] = factory;\n    this[kClients] = new Map();\n    this[kFinalizer] = new FinalizationRegistry(\n    /* istanbul ignore next: gc is undeterministic */\n    key => {\n      const ref = this[kClients].get(key);\n\n      if (ref !== undefined && ref.deref() === undefined) {\n        this[kClients].delete(key);\n      }\n    });\n    const agent = this;\n\n    this[kOnDrain] = (origin, targets) => {\n      agent.emit('drain', origin, [agent, ...targets]);\n    };\n\n    this[kOnConnect] = (origin, targets) => {\n      agent.emit('connect', origin, [agent, ...targets]);\n    };\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      agent.emit('disconnect', origin, [agent, ...targets], err);\n    };\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      agent.emit('connectionError', origin, [agent, ...targets], err);\n    };\n  }\n\n  get [kRunning]() {\n    let ret = 0;\n\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref();\n      /* istanbul ignore next: gc is undeterministic */\n\n      if (client) {\n        ret += client[kRunning];\n      }\n    }\n\n    return ret;\n  }\n\n  [kDispatch](opts, handler) {\n    let key;\n\n    if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {\n      key = String(opts.origin);\n    } else {\n      throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.');\n    }\n\n    const ref = this[kClients].get(key);\n    let dispatcher = ref ? ref.deref() : null;\n\n    if (!dispatcher) {\n      dispatcher = this[kFactory](opts.origin, this[kOptions]).on('drain', this[kOnDrain]).on('connect', this[kOnConnect]).on('disconnect', this[kOnDisconnect]).on('connectionError', this[kOnConnectionError]);\n      this[kClients].set(key, new WeakRef(dispatcher));\n      this[kFinalizer].register(dispatcher, key);\n    }\n\n    const {\n      maxRedirections = this[kMaxRedirections]\n    } = opts;\n\n    if (maxRedirections != null && maxRedirections !== 0) {\n      opts = { ...opts,\n        maxRedirections: 0\n      }; // Stop sub dispatcher from also redirecting.\n\n      handler = new RedirectHandler(this, maxRedirections, opts, handler);\n    }\n\n    return dispatcher.dispatch(opts, handler);\n  }\n\n  async [kClose]() {\n    const closePromises = [];\n\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref();\n      /* istanbul ignore else: gc is undeterministic */\n\n      if (client) {\n        closePromises.push(client.close());\n      }\n    }\n\n    await Promise.all(closePromises);\n  }\n\n  async [kDestroy](err) {\n    const destroyPromises = [];\n\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref();\n      /* istanbul ignore else: gc is undeterministic */\n\n      if (client) {\n        destroyPromises.push(client.destroy(err));\n      }\n    }\n\n    await Promise.all(destroyPromises);\n  }\n\n}\n\nmodule.exports = Agent;","map":{"version":3,"names":["InvalidArgumentError","require","kClients","kRunning","kClose","kDestroy","kDispatch","DispatcherBase","Pool","Client","util","RedirectHandler","WeakRef","FinalizationRegistry","kOnConnect","Symbol","kOnDisconnect","kOnConnectionError","kMaxRedirections","kOnDrain","kFactory","kFinalizer","kOptions","defaultFactory","origin","opts","connections","Agent","constructor","factory","maxRedirections","connect","options","Number","isInteger","deepClone","Map","key","ref","get","undefined","deref","delete","agent","targets","emit","err","ret","values","client","handler","URL","String","dispatcher","on","set","register","dispatch","closePromises","push","close","Promise","all","destroyPromises","destroy","module","exports"],"sources":["/Users/noviaantony/Desktop/CS203-Team-2/carbonO_frontend/node_modules/undici/lib/agent.js"],"sourcesContent":["'use strict'\n\nconst { InvalidArgumentError } = require('./core/errors')\nconst { kClients, kRunning, kClose, kDestroy, kDispatch } = require('./core/symbols')\nconst DispatcherBase = require('./dispatcher-base')\nconst Pool = require('./pool')\nconst Client = require('./client')\nconst util = require('./core/util')\nconst RedirectHandler = require('./handler/redirect')\nconst { WeakRef, FinalizationRegistry } = require('./compat/dispatcher-weakref')()\n\nconst kOnConnect = Symbol('onConnect')\nconst kOnDisconnect = Symbol('onDisconnect')\nconst kOnConnectionError = Symbol('onConnectionError')\nconst kMaxRedirections = Symbol('maxRedirections')\nconst kOnDrain = Symbol('onDrain')\nconst kFactory = Symbol('factory')\nconst kFinalizer = Symbol('finalizer')\nconst kOptions = Symbol('options')\n\nfunction defaultFactory (origin, opts) {\n  return opts && opts.connections === 1\n    ? new Client(origin, opts)\n    : new Pool(origin, opts)\n}\n\nclass Agent extends DispatcherBase {\n  constructor ({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {\n    super()\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    if (connect && typeof connect !== 'function') {\n      connect = { ...connect }\n    }\n\n    this[kOptions] = { ...util.deepClone(options), connect }\n    this[kMaxRedirections] = maxRedirections\n    this[kFactory] = factory\n    this[kClients] = new Map()\n    this[kFinalizer] = new FinalizationRegistry(/* istanbul ignore next: gc is undeterministic */ key => {\n      const ref = this[kClients].get(key)\n      if (ref !== undefined && ref.deref() === undefined) {\n        this[kClients].delete(key)\n      }\n    })\n\n    const agent = this\n\n    this[kOnDrain] = (origin, targets) => {\n      agent.emit('drain', origin, [agent, ...targets])\n    }\n\n    this[kOnConnect] = (origin, targets) => {\n      agent.emit('connect', origin, [agent, ...targets])\n    }\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      agent.emit('disconnect', origin, [agent, ...targets], err)\n    }\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      agent.emit('connectionError', origin, [agent, ...targets], err)\n    }\n  }\n\n  get [kRunning] () {\n    let ret = 0\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref()\n      /* istanbul ignore next: gc is undeterministic */\n      if (client) {\n        ret += client[kRunning]\n      }\n    }\n    return ret\n  }\n\n  [kDispatch] (opts, handler) {\n    let key\n    if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {\n      key = String(opts.origin)\n    } else {\n      throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.')\n    }\n\n    const ref = this[kClients].get(key)\n\n    let dispatcher = ref ? ref.deref() : null\n    if (!dispatcher) {\n      dispatcher = this[kFactory](opts.origin, this[kOptions])\n        .on('drain', this[kOnDrain])\n        .on('connect', this[kOnConnect])\n        .on('disconnect', this[kOnDisconnect])\n        .on('connectionError', this[kOnConnectionError])\n\n      this[kClients].set(key, new WeakRef(dispatcher))\n      this[kFinalizer].register(dispatcher, key)\n    }\n\n    const { maxRedirections = this[kMaxRedirections] } = opts\n    if (maxRedirections != null && maxRedirections !== 0) {\n      opts = { ...opts, maxRedirections: 0 } // Stop sub dispatcher from also redirecting.\n      handler = new RedirectHandler(this, maxRedirections, opts, handler)\n    }\n\n    return dispatcher.dispatch(opts, handler)\n  }\n\n  async [kClose] () {\n    const closePromises = []\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref()\n      /* istanbul ignore else: gc is undeterministic */\n      if (client) {\n        closePromises.push(client.close())\n      }\n    }\n\n    await Promise.all(closePromises)\n  }\n\n  async [kDestroy] (err) {\n    const destroyPromises = []\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref()\n      /* istanbul ignore else: gc is undeterministic */\n      if (client) {\n        destroyPromises.push(client.destroy(err))\n      }\n    }\n\n    await Promise.all(destroyPromises)\n  }\n}\n\nmodule.exports = Agent\n"],"mappings":"AAAA;;AAEA,MAAM;EAAEA;AAAF,IAA2BC,OAAO,CAAC,eAAD,CAAxC;;AACA,MAAM;EAAEC,QAAF;EAAYC,QAAZ;EAAsBC,MAAtB;EAA8BC,QAA9B;EAAwCC;AAAxC,IAAsDL,OAAO,CAAC,gBAAD,CAAnE;;AACA,MAAMM,cAAc,GAAGN,OAAO,CAAC,mBAAD,CAA9B;;AACA,MAAMO,IAAI,GAAGP,OAAO,CAAC,QAAD,CAApB;;AACA,MAAMQ,MAAM,GAAGR,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAMS,IAAI,GAAGT,OAAO,CAAC,aAAD,CAApB;;AACA,MAAMU,eAAe,GAAGV,OAAO,CAAC,oBAAD,CAA/B;;AACA,MAAM;EAAEW,OAAF;EAAWC;AAAX,IAAoCZ,OAAO,CAAC,6BAAD,CAAP,EAA1C;;AAEA,MAAMa,UAAU,GAAGC,MAAM,CAAC,WAAD,CAAzB;AACA,MAAMC,aAAa,GAAGD,MAAM,CAAC,cAAD,CAA5B;AACA,MAAME,kBAAkB,GAAGF,MAAM,CAAC,mBAAD,CAAjC;AACA,MAAMG,gBAAgB,GAAGH,MAAM,CAAC,iBAAD,CAA/B;AACA,MAAMI,QAAQ,GAAGJ,MAAM,CAAC,SAAD,CAAvB;AACA,MAAMK,QAAQ,GAAGL,MAAM,CAAC,SAAD,CAAvB;AACA,MAAMM,UAAU,GAAGN,MAAM,CAAC,WAAD,CAAzB;AACA,MAAMO,QAAQ,GAAGP,MAAM,CAAC,SAAD,CAAvB;;AAEA,SAASQ,cAAT,CAAyBC,MAAzB,EAAiCC,IAAjC,EAAuC;EACrC,OAAOA,IAAI,IAAIA,IAAI,CAACC,WAAL,KAAqB,CAA7B,GACH,IAAIjB,MAAJ,CAAWe,MAAX,EAAmBC,IAAnB,CADG,GAEH,IAAIjB,IAAJ,CAASgB,MAAT,EAAiBC,IAAjB,CAFJ;AAGD;;AAED,MAAME,KAAN,SAAoBpB,cAApB,CAAmC;EACjCqB,WAAW,GAA+E;IAAA,IAA7E;MAAEC,OAAO,GAAGN,cAAZ;MAA4BO,eAAe,GAAG,CAA9C;MAAiDC,OAAjD;MAA0D,GAAGC;IAA7D,CAA6E,uEAAJ,EAAI;IACxF;;IAEA,IAAI,OAAOH,OAAP,KAAmB,UAAvB,EAAmC;MACjC,MAAM,IAAI7B,oBAAJ,CAAyB,6BAAzB,CAAN;IACD;;IAED,IAAI+B,OAAO,IAAI,IAAX,IAAmB,OAAOA,OAAP,KAAmB,UAAtC,IAAoD,OAAOA,OAAP,KAAmB,QAA3E,EAAqF;MACnF,MAAM,IAAI/B,oBAAJ,CAAyB,yCAAzB,CAAN;IACD;;IAED,IAAI,CAACiC,MAAM,CAACC,SAAP,CAAiBJ,eAAjB,CAAD,IAAsCA,eAAe,GAAG,CAA5D,EAA+D;MAC7D,MAAM,IAAI9B,oBAAJ,CAAyB,2CAAzB,CAAN;IACD;;IAED,IAAI+B,OAAO,IAAI,OAAOA,OAAP,KAAmB,UAAlC,EAA8C;MAC5CA,OAAO,GAAG,EAAE,GAAGA;MAAL,CAAV;IACD;;IAED,KAAKT,QAAL,IAAiB,EAAE,GAAGZ,IAAI,CAACyB,SAAL,CAAeH,OAAf,CAAL;MAA8BD;IAA9B,CAAjB;IACA,KAAKb,gBAAL,IAAyBY,eAAzB;IACA,KAAKV,QAAL,IAAiBS,OAAjB;IACA,KAAK3B,QAAL,IAAiB,IAAIkC,GAAJ,EAAjB;IACA,KAAKf,UAAL,IAAmB,IAAIR,oBAAJ;IAAyB;IAAkDwB,GAAG,IAAI;MACnG,MAAMC,GAAG,GAAG,KAAKpC,QAAL,EAAeqC,GAAf,CAAmBF,GAAnB,CAAZ;;MACA,IAAIC,GAAG,KAAKE,SAAR,IAAqBF,GAAG,CAACG,KAAJ,OAAgBD,SAAzC,EAAoD;QAClD,KAAKtC,QAAL,EAAewC,MAAf,CAAsBL,GAAtB;MACD;IACF,CALkB,CAAnB;IAOA,MAAMM,KAAK,GAAG,IAAd;;IAEA,KAAKxB,QAAL,IAAiB,CAACK,MAAD,EAASoB,OAAT,KAAqB;MACpCD,KAAK,CAACE,IAAN,CAAW,OAAX,EAAoBrB,MAApB,EAA4B,CAACmB,KAAD,EAAQ,GAAGC,OAAX,CAA5B;IACD,CAFD;;IAIA,KAAK9B,UAAL,IAAmB,CAACU,MAAD,EAASoB,OAAT,KAAqB;MACtCD,KAAK,CAACE,IAAN,CAAW,SAAX,EAAsBrB,MAAtB,EAA8B,CAACmB,KAAD,EAAQ,GAAGC,OAAX,CAA9B;IACD,CAFD;;IAIA,KAAK5B,aAAL,IAAsB,CAACQ,MAAD,EAASoB,OAAT,EAAkBE,GAAlB,KAA0B;MAC9CH,KAAK,CAACE,IAAN,CAAW,YAAX,EAAyBrB,MAAzB,EAAiC,CAACmB,KAAD,EAAQ,GAAGC,OAAX,CAAjC,EAAsDE,GAAtD;IACD,CAFD;;IAIA,KAAK7B,kBAAL,IAA2B,CAACO,MAAD,EAASoB,OAAT,EAAkBE,GAAlB,KAA0B;MACnDH,KAAK,CAACE,IAAN,CAAW,iBAAX,EAA8BrB,MAA9B,EAAsC,CAACmB,KAAD,EAAQ,GAAGC,OAAX,CAAtC,EAA2DE,GAA3D;IACD,CAFD;EAGD;;EAEY,KAAR3C,QAAQ,IAAK;IAChB,IAAI4C,GAAG,GAAG,CAAV;;IACA,KAAK,MAAMT,GAAX,IAAkB,KAAKpC,QAAL,EAAe8C,MAAf,EAAlB,EAA2C;MACzC,MAAMC,MAAM,GAAGX,GAAG,CAACG,KAAJ,EAAf;MACA;;MACA,IAAIQ,MAAJ,EAAY;QACVF,GAAG,IAAIE,MAAM,CAAC9C,QAAD,CAAb;MACD;IACF;;IACD,OAAO4C,GAAP;EACD;;EAES,CAATzC,SAAS,EAAGmB,IAAH,EAASyB,OAAT,EAAkB;IAC1B,IAAIb,GAAJ;;IACA,IAAIZ,IAAI,CAACD,MAAL,KAAgB,OAAOC,IAAI,CAACD,MAAZ,KAAuB,QAAvB,IAAmCC,IAAI,CAACD,MAAL,YAAuB2B,GAA1E,CAAJ,EAAoF;MAClFd,GAAG,GAAGe,MAAM,CAAC3B,IAAI,CAACD,MAAN,CAAZ;IACD,CAFD,MAEO;MACL,MAAM,IAAIxB,oBAAJ,CAAyB,gDAAzB,CAAN;IACD;;IAED,MAAMsC,GAAG,GAAG,KAAKpC,QAAL,EAAeqC,GAAf,CAAmBF,GAAnB,CAAZ;IAEA,IAAIgB,UAAU,GAAGf,GAAG,GAAGA,GAAG,CAACG,KAAJ,EAAH,GAAiB,IAArC;;IACA,IAAI,CAACY,UAAL,EAAiB;MACfA,UAAU,GAAG,KAAKjC,QAAL,EAAeK,IAAI,CAACD,MAApB,EAA4B,KAAKF,QAAL,CAA5B,EACVgC,EADU,CACP,OADO,EACE,KAAKnC,QAAL,CADF,EAEVmC,EAFU,CAEP,SAFO,EAEI,KAAKxC,UAAL,CAFJ,EAGVwC,EAHU,CAGP,YAHO,EAGO,KAAKtC,aAAL,CAHP,EAIVsC,EAJU,CAIP,iBAJO,EAIY,KAAKrC,kBAAL,CAJZ,CAAb;MAMA,KAAKf,QAAL,EAAeqD,GAAf,CAAmBlB,GAAnB,EAAwB,IAAIzB,OAAJ,CAAYyC,UAAZ,CAAxB;MACA,KAAKhC,UAAL,EAAiBmC,QAAjB,CAA0BH,UAA1B,EAAsChB,GAAtC;IACD;;IAED,MAAM;MAAEP,eAAe,GAAG,KAAKZ,gBAAL;IAApB,IAA+CO,IAArD;;IACA,IAAIK,eAAe,IAAI,IAAnB,IAA2BA,eAAe,KAAK,CAAnD,EAAsD;MACpDL,IAAI,GAAG,EAAE,GAAGA,IAAL;QAAWK,eAAe,EAAE;MAA5B,CAAP,CADoD,CACb;;MACvCoB,OAAO,GAAG,IAAIvC,eAAJ,CAAoB,IAApB,EAA0BmB,eAA1B,EAA2CL,IAA3C,EAAiDyB,OAAjD,CAAV;IACD;;IAED,OAAOG,UAAU,CAACI,QAAX,CAAoBhC,IAApB,EAA0ByB,OAA1B,CAAP;EACD;;EAEY,OAAN9C,MAAM,IAAK;IAChB,MAAMsD,aAAa,GAAG,EAAtB;;IACA,KAAK,MAAMpB,GAAX,IAAkB,KAAKpC,QAAL,EAAe8C,MAAf,EAAlB,EAA2C;MACzC,MAAMC,MAAM,GAAGX,GAAG,CAACG,KAAJ,EAAf;MACA;;MACA,IAAIQ,MAAJ,EAAY;QACVS,aAAa,CAACC,IAAd,CAAmBV,MAAM,CAACW,KAAP,EAAnB;MACD;IACF;;IAED,MAAMC,OAAO,CAACC,GAAR,CAAYJ,aAAZ,CAAN;EACD;;EAEc,OAARrD,QAAQ,EAAGyC,GAAH,EAAQ;IACrB,MAAMiB,eAAe,GAAG,EAAxB;;IACA,KAAK,MAAMzB,GAAX,IAAkB,KAAKpC,QAAL,EAAe8C,MAAf,EAAlB,EAA2C;MACzC,MAAMC,MAAM,GAAGX,GAAG,CAACG,KAAJ,EAAf;MACA;;MACA,IAAIQ,MAAJ,EAAY;QACVc,eAAe,CAACJ,IAAhB,CAAqBV,MAAM,CAACe,OAAP,CAAelB,GAAf,CAArB;MACD;IACF;;IAED,MAAMe,OAAO,CAACC,GAAR,CAAYC,eAAZ,CAAN;EACD;;AArHgC;;AAwHnCE,MAAM,CAACC,OAAP,GAAiBvC,KAAjB"},"metadata":{},"sourceType":"script"}