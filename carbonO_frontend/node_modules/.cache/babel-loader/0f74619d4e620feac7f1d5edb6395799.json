{"ast":null,"code":"'use strict';\n\nconst {\n  kClose,\n  kDestroy\n} = require('./core/symbols');\n\nconst Client = require('./agent');\n\nconst Agent = require('./agent');\n\nconst DispatcherBase = require('./dispatcher-base');\n\nconst {\n  InvalidArgumentError,\n  RequestAbortedError\n} = require('./core/errors');\n\nconst buildConnector = require('./core/connect');\n\nconst kAgent = Symbol('proxy agent');\nconst kClient = Symbol('proxy client');\nconst kProxyHeaders = Symbol('proxy headers');\nconst kRequestTls = Symbol('request tls settings');\nconst kProxyTls = Symbol('proxy tls settings');\nconst kConnectEndpoint = Symbol('connect endpoint function');\n\nfunction defaultProtocolPort(protocol) {\n  return protocol === 'https:' ? 443 : 80;\n}\n\nclass ProxyAgent extends DispatcherBase {\n  constructor(opts) {\n    super(opts);\n\n    if (typeof opts === 'string') {\n      opts = {\n        uri: opts\n      };\n    }\n\n    if (!opts || !opts.uri) {\n      throw new InvalidArgumentError('Proxy opts.uri is mandatory');\n    }\n\n    this[kRequestTls] = opts.requestTls;\n    this[kProxyTls] = opts.proxyTls;\n    this[kProxyHeaders] = {};\n\n    if (opts.auth) {\n      this[kProxyHeaders]['proxy-authorization'] = `Basic ${opts.auth}`;\n    }\n\n    const {\n      origin,\n      port\n    } = new URL(opts.uri);\n    const connect = buildConnector({ ...opts.proxyTls\n    });\n    this[kConnectEndpoint] = buildConnector({ ...opts.requestTls\n    });\n    this[kClient] = new Client({\n      origin: opts.origin,\n      connect\n    });\n    this[kAgent] = new Agent({ ...opts,\n      connect: async (opts, callback) => {\n        let requestedHost = opts.host;\n\n        if (!opts.port) {\n          requestedHost += `:${defaultProtocolPort(opts.protocol)}`;\n        }\n\n        try {\n          const {\n            socket,\n            statusCode\n          } = await this[kClient].connect({\n            origin,\n            port,\n            path: requestedHost,\n            signal: opts.signal,\n            headers: { ...this[kProxyHeaders],\n              host: opts.host\n            }\n          });\n\n          if (statusCode !== 200) {\n            socket.on('error', () => {}).destroy();\n            callback(new RequestAbortedError('Proxy response !== 200 when HTTP Tunneling'));\n          }\n\n          if (opts.protocol !== 'https:') {\n            callback(null, socket);\n            return;\n          }\n\n          let servername;\n\n          if (this[kRequestTls]) {\n            servername = this[kRequestTls].servername;\n          } else {\n            servername = opts.servername;\n          }\n\n          this[kConnectEndpoint]({ ...opts,\n            servername,\n            httpSocket: socket\n          }, callback);\n        } catch (err) {\n          callback(err);\n        }\n      }\n    });\n  }\n\n  dispatch(opts, handler) {\n    const {\n      host\n    } = new URL(opts.origin);\n    const headers = buildHeaders(opts.headers);\n    throwIfProxyAuthIsSent(headers);\n    return this[kAgent].dispatch({ ...opts,\n      headers: { ...headers,\n        host\n      }\n    }, handler);\n  }\n\n  async [kClose]() {\n    await this[kAgent].close();\n    await this[kClient].close();\n  }\n\n  async [kDestroy]() {\n    await this[kAgent].destroy();\n    await this[kClient].destroy();\n  }\n\n}\n/**\n * @param {string[] | Record<string, string>} headers\n * @returns {Record<string, string>}\n */\n\n\nfunction buildHeaders(headers) {\n  // When using undici.fetch, the headers list is stored\n  // as an array.\n  if (Array.isArray(headers)) {\n    /** @type {Record<string, string>} */\n    const headersPair = {};\n\n    for (let i = 0; i < headers.length; i += 2) {\n      headersPair[headers[i]] = headers[i + 1];\n    }\n\n    return headersPair;\n  }\n\n  return headers;\n}\n/**\n * @param {Record<string, string>} headers\n *\n * Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers\n * Nevertheless, it was changed and to avoid a security vulnerability by end users\n * this check was created.\n * It should be removed in the next major version for performance reasons\n */\n\n\nfunction throwIfProxyAuthIsSent(headers) {\n  const existProxyAuth = headers && Object.keys(headers).find(key => key.toLowerCase() === 'proxy-authorization');\n\n  if (existProxyAuth) {\n    throw new InvalidArgumentError('Proxy-Authorization should be sent in ProxyAgent constructor');\n  }\n}\n\nmodule.exports = ProxyAgent;","map":{"version":3,"names":["kClose","kDestroy","require","Client","Agent","DispatcherBase","InvalidArgumentError","RequestAbortedError","buildConnector","kAgent","Symbol","kClient","kProxyHeaders","kRequestTls","kProxyTls","kConnectEndpoint","defaultProtocolPort","protocol","ProxyAgent","constructor","opts","uri","requestTls","proxyTls","auth","origin","port","URL","connect","callback","requestedHost","host","socket","statusCode","path","signal","headers","on","destroy","servername","httpSocket","err","dispatch","handler","buildHeaders","throwIfProxyAuthIsSent","close","Array","isArray","headersPair","i","length","existProxyAuth","Object","keys","find","key","toLowerCase","module","exports"],"sources":["/Users/noviaantony/Desktop/CS203-Team-2/carbonO_frontend/node_modules/undici/lib/proxy-agent.js"],"sourcesContent":["'use strict'\n\nconst { kClose, kDestroy } = require('./core/symbols')\nconst Client = require('./agent')\nconst Agent = require('./agent')\nconst DispatcherBase = require('./dispatcher-base')\nconst { InvalidArgumentError, RequestAbortedError } = require('./core/errors')\nconst buildConnector = require('./core/connect')\n\nconst kAgent = Symbol('proxy agent')\nconst kClient = Symbol('proxy client')\nconst kProxyHeaders = Symbol('proxy headers')\nconst kRequestTls = Symbol('request tls settings')\nconst kProxyTls = Symbol('proxy tls settings')\nconst kConnectEndpoint = Symbol('connect endpoint function')\n\nfunction defaultProtocolPort (protocol) {\n  return protocol === 'https:' ? 443 : 80\n}\n\nclass ProxyAgent extends DispatcherBase {\n  constructor (opts) {\n    super(opts)\n\n    if (typeof opts === 'string') {\n      opts = { uri: opts }\n    }\n\n    if (!opts || !opts.uri) {\n      throw new InvalidArgumentError('Proxy opts.uri is mandatory')\n    }\n\n    this[kRequestTls] = opts.requestTls\n    this[kProxyTls] = opts.proxyTls\n    this[kProxyHeaders] = {}\n\n    if (opts.auth) {\n      this[kProxyHeaders]['proxy-authorization'] = `Basic ${opts.auth}`\n    }\n\n    const { origin, port } = new URL(opts.uri)\n\n    const connect = buildConnector({ ...opts.proxyTls })\n    this[kConnectEndpoint] = buildConnector({ ...opts.requestTls })\n    this[kClient] = new Client({ origin: opts.origin, connect })\n    this[kAgent] = new Agent({\n      ...opts,\n      connect: async (opts, callback) => {\n        let requestedHost = opts.host\n        if (!opts.port) {\n          requestedHost += `:${defaultProtocolPort(opts.protocol)}`\n        }\n        try {\n          const { socket, statusCode } = await this[kClient].connect({\n            origin,\n            port,\n            path: requestedHost,\n            signal: opts.signal,\n            headers: {\n              ...this[kProxyHeaders],\n              host: opts.host\n            }\n          })\n          if (statusCode !== 200) {\n            socket.on('error', () => {}).destroy()\n            callback(new RequestAbortedError('Proxy response !== 200 when HTTP Tunneling'))\n          }\n          if (opts.protocol !== 'https:') {\n            callback(null, socket)\n            return\n          }\n          let servername\n          if (this[kRequestTls]) {\n            servername = this[kRequestTls].servername\n          } else {\n            servername = opts.servername\n          }\n          this[kConnectEndpoint]({ ...opts, servername, httpSocket: socket }, callback)\n        } catch (err) {\n          callback(err)\n        }\n      }\n    })\n  }\n\n  dispatch (opts, handler) {\n    const { host } = new URL(opts.origin)\n    const headers = buildHeaders(opts.headers)\n    throwIfProxyAuthIsSent(headers)\n    return this[kAgent].dispatch(\n      {\n        ...opts,\n        headers: {\n          ...headers,\n          host\n        }\n      },\n      handler\n    )\n  }\n\n  async [kClose] () {\n    await this[kAgent].close()\n    await this[kClient].close()\n  }\n\n  async [kDestroy] () {\n    await this[kAgent].destroy()\n    await this[kClient].destroy()\n  }\n}\n\n/**\n * @param {string[] | Record<string, string>} headers\n * @returns {Record<string, string>}\n */\nfunction buildHeaders (headers) {\n  // When using undici.fetch, the headers list is stored\n  // as an array.\n  if (Array.isArray(headers)) {\n    /** @type {Record<string, string>} */\n    const headersPair = {}\n\n    for (let i = 0; i < headers.length; i += 2) {\n      headersPair[headers[i]] = headers[i + 1]\n    }\n\n    return headersPair\n  }\n\n  return headers\n}\n\n/**\n * @param {Record<string, string>} headers\n *\n * Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers\n * Nevertheless, it was changed and to avoid a security vulnerability by end users\n * this check was created.\n * It should be removed in the next major version for performance reasons\n */\nfunction throwIfProxyAuthIsSent (headers) {\n  const existProxyAuth = headers && Object.keys(headers)\n    .find((key) => key.toLowerCase() === 'proxy-authorization')\n  if (existProxyAuth) {\n    throw new InvalidArgumentError('Proxy-Authorization should be sent in ProxyAgent constructor')\n  }\n}\n\nmodule.exports = ProxyAgent\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}